# ‚ùó‚ùóNa aula de hoje vamos seguir um objetivo de aprendizagem‚ùó‚ùó

### üìöSeguindo os seguintes conte√∫dos:
* Par√¢metros posicionais, opcionais e nomeados;
* Function Parameter (FP);
* Anonymous Function (FA);
* Arrow function (AR);

### Objetivos da aula:
  * Aprender todos os tipos de fun√ß√µes em dart flutter
### Realiza√ß√£o na aula:
  * Cria√ß√£o e aplica√ß√£o de fun√ß√µes para refor√ßar o entendimento.
### Dificuldades:
  * Nenhuma
### Principais aprendizagens:
  * Saber os tipos FP, FA e AR.



### üóøüç∑Com o objetivo de aprender:
* Compreens√£o na Sem√¢ntica;  
`Ser capz de exemplificar`  
* Dom√≠nio na Sintaxe;  
`Ser capaz de codificar e entender sem consulta`
* Dom√≠nio em diferencias ";" e ",;  
`Ser capaz de codificar e entender sem consulta`
* Capacidade de escrita/leitura das FP, FA e AR.  
`Ser capaz de codificar sem consulta`  

### O que s√£o fun√ß√µes???
```
√â basicamente um conjuto de c√≥digos que pode ser chamado para realizar determinada tarefa quantas vezes forem necessarias. 
```
Chamando na main:  
`print(funcao(4,4))`  -- Chama a fun√ß√£o.  
`funcao(a, b)` {  -- Com par√¢metro e com retorno.  
return (a + b);  
}
### O que √© top Level Function?
```
√â uma fun√ß√£o que pode ser chamada diretamente, sem criar objeto ou chamar classe ou fu√ß√µes.
```
## Existem 4 tipos de fun√ß√µes:
* Sem retorno e sem par√¢metro:
```
void verificarAprovacao2() {
  double nota1, nota2, media;

  print('informa nota1: ');
  nota1 = double.parse(stdin.readLineSync()!);

  print('informa nota2: ');
  nota2 = double.parse(stdin.readLineSync()!);

  media = (nota1 + nota2) / 2;
```
* Sem retorno e com par√¢metro:
```
void verificarAprovacao3(double nota1, double nota2) {
  double media = (nota1 + nota2) / 2;
  print((media >= 6) ? 'aprovado' : 'reprovado');
}
```
* Com retorno e sem par√¢metro:
```
verificarAprovacao4() {
  double nota1, nota2, media;

  print('informa nota1: ');
  nota1 = double.parse(stdin.readLineSync()!);

  print('informa nota2: ');
  nota2 = double.parse(stdin.readLineSync()!);

  media = (nota1 + nota2) / 2;

  if (media >= 6) {
    return 'aprovado';
  } else {
    return 'reprovado';
  }
}

```
* Com retorno e com par√¢metro:
```
String verificarAprovacao5(double nota1, double nota2) {
  var media = (nota1 + nota2 / 2);
  if (media >= 6) {
    return 'aprovado';
  } else {
    return 'reprovado';
  }
}
```

## Par√¢metros posicionais, opcionais e nomeados:
* Posicionais:

S√£o par√¢metros em que h√° a descri√ß√£o, melhorando a legibilidade e permitindo a defini√ß√£o dos par√¢metros em ordem aleat√≥ria.

  Na chamada da fun√ß√£o __verificarAprovacao__:
  (1) somos obrigados a informar todos os par√¢metros
  (2) somos obrigados e informar na sequ√™ncia correta
 ```
  var valor = verificarAprovacao(nota1, nota2, 6);  
  print(valor);   
```
Na chamada da fun√ß√£o com par√¢metros nomeados
  ‚Üí definindo a m√©dia que √© um valor opcional
```
  valor = verificarAprovacaoComParametrosNomeados(nota1 : 6, nota2 : 8, media: 7);   
  print(valor); 
```
__Par√¢metros nomeados:__
* Define-se par√¢metros nomeados por meio de {}
* Por padr√£o os par√¢metros nomeados s√£o OPCIONAIS - assim √© necess√°rio definir o valor padr√£o
* Para tornar par√¢metros nomeados obrigat√≥rios utilizamos a palavra chave "required"
* O objetivo dos par√¢metros nomeados √© tornar a leitura mais claro 

Com _par√¢metros nomeados_, na chamada da fun√ß√£o, podemos definir a _ordem aleat√≥ria dos par√¢metros_
```
String verificarAprovacaoComParametrosNomeados({required double nota1, required double nota2, double media = 6}){
  double nota =  (nota1 + nota2) / 2;
  if(nota > media){
    return 'aprovado';
  }else{
    return 'reprovado';
  }
}
```
```
String verificarAprovacaoComParametrosNomeadosEAnonimos(double nota1, {double nota2 = 0, double media = 6}){
  double nota;
  if(nota2 == 0){
    nota = nota1;
  }else{
    nota =  (nota1 + nota2) / 2;
  }
  if(nota > media){
    return 'aprovado';
  }else{
    return 'reprovado';
  }
}
```

## Function Parameter (FP):
Ele √© usado quando precisamos de uma a√ß√£o, n√≥s sabemos o que √© preciso mas sabemos como fazer.

Exemplo: 
```
A fun√ß√£o verificarAprova√ß√£o precisa definir uma nota para que seja poss√≠vel verificar a aprova√ß√£o. 
Sabemos "o que" √© preciso ser feito, que no caso √© definir nota.
Por√©m, n√£o sabemos exatamente "como", visto que, cada professor pode fazer de uma forma.

Neste contexto, pode-se definir um par√¢metro do tipo de fun√ß√£o para a fun√ß√£o verificarAprova√ß√£o.
Vantagem? Permite adiar a defini√ß√£o de uma a√ß√£o.
Neste arquivo, vamos definir o par√¢metro do tipo fun√ß√£o e para executar, utilizaremos uma fun√ß√£o nomeada.
```
__Definindo uma fun√ß√£o que tem um par√¢metro do tipo fun√ß√£o (definir nota):__
```
bool verificarAprovacao(double nota1, double nota2, Function definirNota){
    double nota = definirNota(nota1,nota2);
    return (nota >= 6);
}
```

## Anonymous Function (FA):
* Se trata de uma __fun√ß√£o sem nome__, sendo assim, __n√£o pode ser chamada__. Tambem __n√£o pode ser reaproveitada ou executada em mais de um lugar__.
* A sua sintaxe √© a mesma de uma __fun√ß√£o comum__, por√©m __sem nome e defini√ß√£o de retorno__.
* √â utilizada quando para definir uma __a√ß√£o desconhecida__ e que n√£o precisa ser reaproveitada.
* Rap√≠da de implementar e __aumenta a legibilidade__.
* Para usa-la √© __necessario__ ter uma __fun√ß√£o com parametro do tipo fun√ß√µes.__




https://github.com/heliokamakawa/flutter_course/tree/master/lib/modulo_04/aula01_funcoes/01_sintaxe
https://github.com/heliokamakawa/flutter_course/tree/master/lib/modulo_04/aula01_funcoes/02_parametros
https://github.com/heliokamakawa/flutter_course/tree/master/lib/modulo_04/aula01_funcoes/06_function_parameter
https://github.com/heliokamakawa/flutter_course/tree/master/lib/modulo_04/aula01_funcoes/07_funcoes_anonimas
https://github.com/heliokamakawa/flutter_course/tree/master/lib/modulo_04/aula01_funcoes/08_arrow_function

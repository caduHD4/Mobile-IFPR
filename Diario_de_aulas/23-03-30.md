# ðŸŒŒRotas e InterfacesðŸŒŒ

### Os exercicios se encontram na [pasta projetos.](https://github.com/caduHD4/Mobile-IFPR/tree/main/Projetos/projeto1/lib)

### ðŸ“šConteÃºdo:
* ### Conceitos fundamentais para o posicionamento de elementos grÃ¡ficos em rotas de um aplicativo mobile. SÃ£o apresentados os principais elementos grÃ¡ficos, tais como: Scaffold, AppBar, FloatingActionButton, BottomAppBar e Container, que podem ser utilizados na construÃ§Ã£o de interfaces de usuÃ¡rio. AlÃ©m disso, Ã© discutido o processo de prototipaÃ§Ã£o, que consiste em criar um modelo visual do aplicativo antes de sua implementaÃ§Ã£o.

### Objetivos da aula:
 * Compreender os conceitos fundamentais para o posicionamento de elementos grÃ¡ficos em rotas.
 * Discutir o processo de prototipaÃ§Ã£o, que consiste em criar um modelo visual do aplicativo antes de sua implementaÃ§Ã£o.
 * Aprender sobre rotas (Route) em Flutter, para que servem e como definir uma rota usando a classe "MaterialPageRoute".
 * Aprender como implementar uma navegaÃ§Ã£o em um aplicativo Flutter, definindo rotas para cada widget, criando um widget inicial contendo o "Navigator" e um mÃ©todo para definir as aÃ§Ãµes a serem executadas para navegar entre as rotas, alÃ©m de botÃµes em cada tela para navegar entre elas chamando o mÃ©todo "Navigator".

### RealizaÃ§Ã£o na aula:
 * 13 atividades para responder e implementar no projeto.

### Dificuldades:
 Dificuldades em alterar as rotas, e bloquear a volta.

### Principais aprendizagens:

### AtividadesðŸ’¥:
* ### 1 - Implemente a navegaÃ§Ã£o de pelo menos 10 widgets do SEU projeto. 
  * Lembre-se que o projeto deve ser Ãºnico, relevante e coerente - deve estar validada pelo professor!
  * De prioridade na lÃ³gica de navegaÃ§Ã£o e no sentido dos widgets - por enquanto nÃ£o precisa "desenhar" completamente;
  * Se der tempo, vai tentando implementar e caso nÃ£o consiga, faÃ§a a prototipaÃ§Ã£o por meio de outro recurso (pode ser no caderno).

* ### 2 - Em flutter, o que Ã© rotas (Route)? Para que serve?
  * SÃ£o um mecanismo que permite a navegaÃ§Ã£o entre diferentes widgets (ou pÃ¡ginas/telas) de um aplicativo.
  * Cada rota Ã© essencialmente uma tela individual do aplicativo, que pode ter seu prÃ³prio conteÃºdo, layout e comportamento.
  * As rotas sÃ£o particularmente Ãºteis para aplicativos com vÃ¡rias telas, pois permitem que vocÃª organize e gerencie a navegaÃ§Ã£o de forma clara e eficiente.
  
* ### 3 - Para definir uma rota (Route) Ã© necessÃ¡rio utilizar qual classe? O construtor requer parÃ¢metro (se sim, indique o tipo e objetivo)?
  * Ã‰ necessario usar a classe ___"MaterialPageRoute"___.
  * O construtor da classe requer um ___*parÃ¢metro obrigatÃ³rio*___, que Ã© uma funÃ§Ã£o que retorna a tela que deve ser exibida quando a rota Ã© acessada. Essa funÃ§Ã£o Ã© geralmente definida como uma classe separada que estende a classe ___"StatefulWidget"___ ou ___"StatelessWidget"___, que Ã© usada para construir a tela em si.
  
  * Exemplo de implementaÃ§Ã£o de uma rota:
   ```
   import 'package:flutter/material.dart';

   class ___MinhaTela___ extends StatelessWidget {
     @override
     Widget build(BuildContext context) {
       return Scaffold(
         appBar: AppBar(title: Text('Minha Tela')),
         body: Center(child: Text('OlÃ¡, mundo!')),
       );
     }
   }

   class ___MinhaRota___ extends StatelessWidget {
     @override
     Widget build(BuildContext context) {
       return MaterialApp(
         title: 'Minha Rota',
         home: Scaffold(
           body: Center(
             child: ElevatedButton(
               onPressed: () {
                 Navigator.push(context, MaterialPageRoute(builder: (context) => MinhaTela()));
               },
               child: Text('Abrir Tela'),
             ),
           ),
         ),
       );
     }
   }
     ```

* ### 4 - Em flutter, o que Ã© necessÃ¡rio para implementar uma "navegaÃ§Ã£o"?
  * 1 -Definir uma rota para cada widget usando a classe "MaterialPageRoute".
  * 2 - Criar um widget como "Pagina inicial", onde deve conter o "Navigator" para que possa ocorrer a navegaÃ§Ã£o.
  * 3 - Dentro do widget inicial fazer um mÃ©todo que difina as aÃ§Ãµes a serem executadas para navegar entre as rotas.
  * 4 - E por fim colocar botÃµes em cada tela para navegar entre elas chamando o mÃ©todo "Navigator".
 
  * Exemplo de uma implementaÃ§Ã£o de navegaÃ§Ã£o:
   ```
   import 'package:flutter/material.dart';

    void main() => runApp(MyApp());

    class MyApp extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Minha App',
          initialRoute: '/',
          routes: {
            '/': (context) => HomePage(),
            '/sobre': (context) => SobrePage(),
            '/contato': (context) => ContatoPage(),
          },
        );
      }
    }

    class HomePage extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: Text('Home')),
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                ElevatedButton(
                  child: Text('Sobre'),
                  onPressed: () {
                    Navigator.pushNamed(context, '/sobre');
                  },
                ),
                ElevatedButton(
                  child: Text('Contato'),
                  onPressed: () {
                    Navigator.pushNamed(context, '/contato');
                  },
                ),
              ],
            ),
          ),
        );
      }
    }

    class SobrePage extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: Text('Sobre')),
          body: Center(
            child: Text('PÃ¡gina sobre o aplicativo'),
          ),
        );
      }
    }

    class ContatoPage extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: Text('Contato')),
          body: Center(
            child: Text('PÃ¡gina de contato'),
          ),
        );
      }
    }

   
   ```

* ### 5 -Quais sÃ£o os principais mÃ©todos de navegaÃ§Ã£o? Explique detalhadamente a assinatura do mÃ©todo.
  * __Navigator.push()__ - Este mÃ©todo empilha uma nova tela na parte superior da pilha de telas do aplicativo. Ele requer um BuildContext (geralmente passado como context) e um Route como parÃ¢metros.

  * Exemplo:
  ```
      Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => NextScreen()),
      );
  ```
  * __Navigator.pushNamed()__ - Este mÃ©todo Ã© semelhante ao Navigator.push(), mas em vez de passar uma instÃ¢ncia de Route, ele usa o nome da rota para identificar a prÃ³xima tela a ser exibida. Este mÃ©todo requer um BuildContext e uma String que representa o nome da rota. Para usar esse mÃ©todo, vocÃª precisa definir as rotas do aplicativo no construtor routes da classe MaterialApp.

  * Exemplo:
  ```
  Navigator.pushNamed(context, '/next');
  ```
  * __Navigator.pop()__ - Este mÃ©todo remove a tela atual da pilha e retorna o usuÃ¡rio Ã  tela anterior. Ele requer um BuildContext como parÃ¢metro e pode opcionalmente passar um valor de retorno para a tela anterior.

  * Exemplo:
  ```
  Navigator.pop(context);
  ```
  * __Navigator.popUntil()__ - Este mÃ©todo permite que vocÃª remova todas as telas da pilha atÃ© chegar a uma determinada rota. Ele requer um BuildContext e um RoutePredicate, que Ã© uma funÃ§Ã£o que recebe um Route e retorna true se a rota desejada for encontrada.
 
  * Exemplo:
  ```
    Navigator.popUntil(context, ModalRoute.withName('/home'));
  ```
  * __Navigator.pushAndRemoveUntil()__ - Este mÃ©todo permite que vocÃª empilhe uma nova tela na parte superior da pilha e, ao mesmo tempo, remova todas as outras telas da pilha atÃ© chegar a uma determinada rota. Ele requer um BuildContext, um Route, e um RoutePredicate.

  * Exemplo:
  ```
    Navigator.pushAndRemoveUntil(
      context,
      MaterialPageRoute(builder: (context) => HomeScreen()),
      ModalRoute.withName('/home'),
    );

  ```

* ### 6 - O "context" Ã© necessÃ¡rio para realizar uma das operaÃ§Ãµes do Navigator. Neste contexto, qual Ã© o seu tipo e para por qual motivo ele Ã© necessÃ¡rio?
  * Ã‰ necessÃ¡rio para realizar operaÃ§Ãµes de navegaÃ§Ã£o com o Navigator porque ele fornece acesso ao objeto NavigatorState e outras informaÃ§Ãµes importantes do aplicativo.

* ### 7 -Exemplifique (sem copiar e colar) o uso de Navigator com e sem a referÃªncia anÃ´nima. Na sua opiniÃ£o: qual a diferenÃ§a? qual Ã© a mais fÃ¡cil? Ã© possÃ­vel entender as duas?

  * Com referÃªncia anÃ´nima:
  ```
    Navigator.push(
    context,
    MaterialPageRoute(builder: (context) => NextScreen()),  <-- A referÃªncia anÃ´nima Ã© usada para
    construir um MaterialPageRoute para a nova tela.
  );

  ```
  * Sem referÃªncia anÃ´nima:
  ```
  Navigator.pushNamed(context, '/next');
  ```
  * A principal diferenÃ§a entre os dois exemplos Ã© que, com a referÃªncia anÃ´nima, vocÃª pode personalizar a transiÃ§Ã£o da tela usando a classe MaterialPageRoute. Com o mÃ©todo pushNamed(), vocÃª nÃ£o tem essa opÃ§Ã£o e a transiÃ§Ã£o padrÃ£o Ã© usada.
 
  * Em termos de facilidade, o mÃ©todo pushNamed() pode ser mais fÃ¡cil de usar, especialmente se vocÃª estiver trabalhando com rotas nomeadas simples. No entanto, se vocÃª precisar personalizar a transiÃ§Ã£o da tela ou usar outras opÃ§Ãµes disponÃ­veis na classe MaterialPageRoute, a referÃªncia anÃ´nima pode ser mais fÃ¡cil de entender e usar.
  * Ambas as formas sÃ£o possÃ­veis de entender e usar, mas a referÃªncia anÃ´nima pode ser mais Ãºtil em casos onde vocÃª precisa personalizar a transiÃ§Ã£o da tela ou usar outras opÃ§Ãµes disponÃ­veis na classe MaterialPageRoute. Em geral, a escolha entre as duas opÃ§Ãµes depende das necessidades especÃ­ficas do seu aplicativo.

* ### 8 - Qual a diferenÃ§a entre push e pushReplacedNamed? Em que caso utilizamos cada uma?
  * A principal diferenÃ§a entre os dois mÃ©todos Ã© que o push adiciona a nova tela Ã  pilha de telas do aplicativo, enquanto o pushReplacementNamed substitui a tela atual na pilha pela nova tela.
  * Em resumo, use push quando quiser adicionar uma nova tela Ã  pilha e permitir que o usuÃ¡rio volte para a tela anterior pressionando o botÃ£o "Voltar". Use pushReplacementNamed quando quiser substituir a tela atual pela nova tela e impedir que o usuÃ¡rio volte para a tela anterior.

* ### 9 - Qual a diferenÃ§a entre pop e popAndPushNamed? Em que caso utilizamos cada uma?
  * A diferenÃ§a entre os dois mÃ©todos Ã© que o pop remove a tela atual da pilha de telas do aplicativo e retorna o usuÃ¡rio para a tela anterior na pilha, enquanto o popAndPushNamed remove a tela atual da pilha e navega para uma nova tela.
  * Usar o pop quando quiser remover a tela atual da pilha e retornar o usuÃ¡rio para a tela anterior. Use popAndPushNamed quando quiser remover a tela atual da pilha e navegar para uma nova tela especificada pela rota nomeada.

* ### 10 - O que sÃ£o e para que servem as rotas nomeadas?
  * As rotas nomeadas sÃ£o uma forma de definir uma rota com um nome especÃ­fico para uma tela em um aplicativo Flutter. Isso permite que vocÃª navegue para uma tela especÃ­fica usando seu nome, em vez de precisar se lembrar da ordem exata em que as telas foram empilhadas na navegaÃ§Ã£o.

  * As rotas nomeadas sÃ£o especialmente Ãºteis em aplicativos maiores com muitas telas, onde Ã© difÃ­cil lembrar a ordem exata em que as telas foram empilhadas na navegaÃ§Ã£o.

* ### 11 - Em relaÃ§Ã£o as rotas, deste as formas apresentadas, qual seria a melhor? Justifique.
 * NÃ£o existe exatamente a "melhor" forma, pois isso depende das necessidades do app.
 * No entanto, as "rotas nomeadas" podem ser uma opÃ§Ã£o mais organizada para aplicativos maiores com muitas telas.
 * Por outro lado, o uso de rotas anÃ´nimas pode ser mais adequado para aplicativos menores ou mais simples, onde a organizaÃ§Ã£o do cÃ³digo nÃ£o Ã© tÃ£o crÃ­tica e vocÃª nÃ£o precisa de nomes especÃ­ficos para cada rota. Ou seja, cabe ao desemvolvedor decidir.

* ### 12 - Em relaÃ§Ã£o ao push e pashNamed: qual a diferenÃ§a? os parametros sÃ£o posicionais ou nomeados?
  * A principal diferenÃ§a entre o push e o pushNamed Ã© que o primeiro requer uma instÃ¢ncia de rota e o segundo requer o nome da rota. E ambos os mÃ©todos permitem que vocÃª passe parÃ¢metros para a prÃ³xima tela, que podem ser nomeados ou posicionais, dependendo da sua preferÃªncia.

* ### 13) REALIZAR ATIVIDADES QUE CONSTA EM: layout/lib/tela/primeira_pagina.dart
